<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html      PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>  <title>RevDoc</title>  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />  <meta http-equiv="Content-Script-Type" content="text/javascript" />  <link rel="stylesheet" href="revdoc-style.css" type="text/css" media="screen" />  <script type="text/javascript"></script></head><body>  <div id="classHeader">        <table class="header-table">        <tr class="top-aligned-row">          <td><strong>Stack</strong></td>          <td class="class-name-in-header"></td>        </tr>        <tr class="top-aligned-row">            <td><strong>File:</strong></td>            <td>               /Users/soapdog/Dropbox/prog/andregarzia.com/DBLib/aagDBLib.livecode        <br />            </td>        </tr>        <tr class="top-aligned-row">            <td><strong>Object:</strong></td>            <td>                stack "aagDBLib"            </td>        </tr>        </table>    </div>  <!-- banner header -->  <div id="bodyContent">  <div id="contextContent">    <div id="description">      <p><?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html      PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>  <title>Class: HTMLEntities</title>  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />  <meta http-equiv="Content-Script-Type" content="text/javascript" />  <link rel="stylesheet" href="revdoc-style.css" type="text/css" media="screen" /></head><body><p>  <h2> AAG DB LIB<br /></h2> <br />  Version 1.11<br />  by Andre Alves Garzia (<a href='mailto:support@andregarzia.com'>mailto:support@andregarzia.com</a>)<br /> <br />  <h3> Objective<br /></h3>  Creating a little ORM library to be used on mobile applications.<br />  This library is inspired by RevIgniter, Rails and others.<br /> <br />  URL: <a href='http://www.andregarzia.com/page/dblib'>http://www.andregarzia.com/page/dblib</a><br />  Online API Documentation: <a href='http://www.andregarzia.com/aux/dblibapi'>http://www.andregarzia.com/aux/dblibapi</a><br />  Guide: <a href='http://www.andregarzia.com/aux/dblibguide'>http://www.andregarzia.com/aux/dblibguide</a><br />  Support Forum: <a href='http://andregarzia.com/forum'>http://andregarzia.com/forum</a>. This is the main venue for getting your questions answered and providing feedback.<br /> <br /></p></body></html></p>    </div>   </div>  <div id="section"> <div id="methods">      <h3 class="section-bar">Functions &amp; Commands</h3><div class="method-detail">        <a name="dbUpdate" />        <div class="method-heading"><a class="method-signature"> <span class="method-name">dbUpdate</span> <span class="method-args">Type: Function    Scope: Public Params: pTable, pDataA, pDatabaseConnectionID</span></a></div><div class="method-description"><p> Updates a record in the database.<br/> <br/> Use a <em>dbWhere<em> or a  </em>dbLike</em> to specify which record. <br/> For example:<br/><br/> <strong> put "contato@andregarzia.com" into tNewDataA["email"] </strong><br/> <strong> dbWhere "email", "andre@andregarzia.com" </strong><br/> <em></em> put dbUpdate("contacts", tNewDataA) into tResult<br/> <br/> This will change the email for that user. It is analogous to executing the following SQL:<br/> <strong> UPDATE contacts SET email = 'contato@andregarzia.com' WHERE email = 'andre@andregarzia.com' </strong><br/><br/> <strong> REMEMBER: </strong> If you don't specify a <em>dbWhere<em> or a  </em>dbLike</em> then the library will return an<br/> error for this call starting with "dberr,". This is to protect you from accidently updating all records<br/> on a given table because you forgot to specify a filter.<br/><br/> This function works on the default connection id unless<br/> you specify an extra parameter with the desired connection id.<br/><br/> <em>Parameters:</em> a table name and a data array.<br/> <em>Parameters:</em> a table name, a data array and a connection id.<br/> <br/> <em>Returns:</em> the result from the inner revExecuteSQL call.<br/><br/></p></div></div><div class="method-detail">        <a name="dbEscapeSqlite" />        <div class="method-heading"><a class="method-signature"> <span class="method-name">dbEscapeSqlite</span> <span class="method-args">Type: Function    Scope: Public Params: pText</span></a></div><div class="method-description"><p> Escapes a string for SQLite usage. <br/> From SQLite documentation, all that is required to escape a string is to escape the single quotes.<br/> <em>Parameter:</em> You pass a string.<br/> <em>Returns:</em> The escaped string.<br/> <em>This escaping routine is here because it might be needed but it is not currently used</em><br/></p></div></div><div class="method-detail">        <a name="dbArrayToCard" />        <div class="method-heading"><a class="method-signature"> <span class="method-name">dbArrayToCard</span> <span class="method-args">Type: Command    Scope: Public Params: pDataA</span></a></div><div class="method-description"><p> This command will loop the keys of an array looking for controls with the same name in the current<br/> card. If it finds a field, button or group with the same name, it will try to replace the current value<br/> for the control with the value from the array.<br/><br/> If you have a card with a field called "firstName", a field called "lastName" and a menu button <br/> called "country" which are all fields on your <em>contacts</em> table and you use:<br/><br/> <strong> dbArrayToCard tDataA </strong><br/><br/> it is the same as writing:<br/><br/> <strong> set the unicodetext of field "firstName" to uniencode(tDataA["firstName"], "unicode") </strong><br/> <strong> set the unicodetext of field "lastName" to uniencode(tDataA["lastName"], "unicode") </strong><br/> <strong> set the label of button "country" to tDataA["country"] </strong><br/><br/> So it follows these rules:<br/> 1 - it looks for a field, it there is one, then it sets the unicodetext property.<br/> 2 - it looks for a button and sets the label.<br/> 3 - it looks for a group and sets the value from the custom property <em>dbvalue</em>.<br/><br/> <strong>REMEMBER:</strong> if you're using groups for your mobile controls, just script a <em>setprop dbvalue</em> and<br/> a <em>getprop dbvalue</em> for the group to be able to exchange data with this command.<br/><br/> <em>Parameters:</em> an array.<br/> <em>Parameters:</em> an array and a connection id.<br/> <br/></p></div></div><div class="method-detail">        <a name="dbLimit" />        <div class="method-heading"><a class="method-signature"> <span class="method-name">dbLimit</span> <span class="method-args">Type: Command    Scope: Public Params: pNum</span></a></div><div class="method-description"><p> This command sets the limit for the query.<br/><br/> <strong> dbLimit 10 </strong><br/> <strong> put dbGet("contacts") into tDataA </strong><br/><br/> Will return up to ten contacts.<br/><br/> <em>Parameters:</em> A valid number for the limit.<br/></p></div></div><div class="method-detail">        <a name="dbGroupBy" />        <div class="method-heading"><a class="method-signature"> <span class="method-name">dbGroupBy</span> <span class="method-args">Type: Command    Scope: Public Params: pData, pHaving</span></a></div><div class="method-description"><p> Sets the grouping options for a query.<br/> <br/> <strong> dbGroupBy 'country' </strong><br/> <em></em> dbColumn 'count(1) as qty'<br/> <strong> put dbGet("contacts") into tDataA </strong><br/><br/> Will return the contacts array grouped by country.<br/> <em>Parameters:</em> A valid column or clause for the grouping.<br/></p></div></div><div class="method-detail">        <a name="dbDelete" />        <div class="method-heading"><a class="method-signature"> <span class="method-name">dbDelete</span> <span class="method-args">Type: Function    Scope: Public Params: pTable, pDatabaseConnectionID</span></a></div><div class="method-description"><p> Deletes a record from the database.<br/> <br/> Use a <em>dbWhere<em> or a  </em>dbLike</em> to specify which record. <br/> For example:<br/><br/> <strong> dbWhere "email", "andre@andregarzia.com" </strong><br/> <em></em> put dbDelete("contacts") into tResult<br/> <br/> This will delete that user. It is analogous to executing the following SQL:<br/> <strong> DELETE FROM contacts WHERE email = 'andre@andregarzia.com' </strong><br/><br/> <strong> REMEMBER: </strong> If you don't specify a <em>dbWhere<em> or a  </em>dbLike</em> then the library will return an<br/> error for this call starting with "dberr,". This is to protect you from accidently deleting all records<br/> on a given table because you forgot to specify a filter.<br/><br/> This function works on the default connection id unless<br/> you specify an extra parameter with the desired connection id.<br/><br/> <em>Parameters:</em> a table name and a data array.<br/> <em>Parameters:</em> a table name, a data array and a connection id.<br/> <br/> <em>Returns:</em> the result from the inner revExecuteSQL call.<br/><br/></p></div></div><div class="method-detail">        <a name="dbInsert" />        <div class="method-heading"><a class="method-signature"> <span class="method-name">dbInsert</span> <span class="method-args">Type: Function    Scope: Public Params: pTable, pDataA, pDatabaseConnectionID</span></a></div><div class="method-description"><p> This function inserts a new record into the database.<br/> It uses an array where each element is a field value with the same keys as the field names<br/> on the database schema.<br/><br/> <strong> put "Andre" into tDataA["firstName"] </strong><br/> <strong> put "Garzia" into tDataA["lastName"] </strong><br/> <strong> put "andre@andregarzia.com" into tDataA["email"] </strong><br/> <strong> put dbInsert("contacts", tDataA) into tResult </strong><br/><br/> Will insert a new record with the values from the array. This function works on the default connection id unless<br/> you specify an extra parameter with the desired connection id.<br/><br/> <em>Parameters:</em> A table name and a data array.<br/> <em>Parameters:</em> A table name, a data array and a connection id.<br/><br/> <em>Returns:</em> the result from the inner revExecuteSQL call.<br/><br/></p></div></div><div class="method-detail">        <a name="dbBatchInsert" />        <div class="method-heading"><a class="method-signature"> <span class="method-name">dbBatchInsert</span> <span class="method-args">Type: Function    Scope: Public Params: pTable, pBatchDataA, pDatabaseConnectionID</span></a></div><div class="method-description"><p> This function performs batch inserts. You pass the table name, the batch data array and an optional database<br/> connection id. The batch data array is an array like the one used by the datagrid. On its first level it has numeric<br/> keys going from 1 to N. In each element in the second level it has a data array.<br/><br/> For Example:<br/><br/> put "andre" into tDataA[1]["first_name"]<br/> put "garzia" into tDataA[1]["last_name"]<br/> put "support@andregarzia.com" into tDataA[1]["email"]<br/><br/> put "claudia" into tDataA[2]["first_name"]<br/> put "donovan" into tDataA[2]["last_name"]<br/> put "claudia@example.com" into tDataA[2]["email"]<br/><br/> get dbBatchInsert("contacts", tDataA)<br/><br/> The return value is the number of records added or an error string that starts with <strong>dberr,</strong>.<br/><br/></p></div></div><div class="method-detail">        <a name="dbGet" />        <div class="method-heading"><a class="method-signature"> <span class="method-name">dbGet</span> <span class="method-args">Type: Function    Scope: Public Params: pTable, pDatabaseConnectionID</span></a></div><div class="method-description"><p> Returns all data from a given table as an array.<br/><br/> You can use commands such as <em>dbWhere, dbLike, dbLimit, dbOrderBy</em> to set <br/> parameters to be used by this function.<br/><br/> If a code like:<br/> <strong> put dbGet("contacts") into tDataA </strong><br/> returns all the contacts. Then a code like:<br/> <strong> dbWhere("country", "Brazil") </strong><br/> <strong> dbWhere("sex", "male") </strong><br/> <strong> put dbGet("contacts") into tDataA </strong><br/> Will return all contacts that are male and from Brazil.<br/><br/> This functions works on the default connection id set with <em>dbSetDefaultConnectionID</em> unless<br/> you pass an extra connection id parameter.<br/><br/> <em>Parameters:</em> A table name.<br/> <em>Parameters:</em> A table name and a connection id.<br/><br/></p></div></div><div class="method-detail">        <a name="dbGetDefaultConnectionID" />        <div class="method-heading"><a class="method-signature"> <span class="method-name">dbGetDefaultConnectionID</span> <span class="method-args">Type: Function    Scope: Public Params: </span></a></div><div class="method-description"><p> This function returns the default database connection id set by dbSetDefaultConnectionID<br/><br/></p></div></div><div class="method-detail">        <a name="dbWhere" />        <div class="method-heading"><a class="method-signature"> <span class="method-name">dbWhere</span> <span class="method-args">Type: Command    Scope: Public Params: pColumn, pValue, pConcatenationOperator</span></a></div><div class="method-description"><p> This command allows you to refine your query. Use it before calling functions such as: <em>dbGet, dbUpdate, dbDelete</em>.<br/><br/> If a code like:<br/> <strong> put dbGet("contacts") into tDataA </strong><br/> returns all the contacts. Then a code like:<br/> <strong> dbWhere "country", "Brazil" </strong><br/> <strong> dbWhere "sex", "male" </strong><br/> <strong> put dbGet("contacts") into tDataA </strong><br/> Will return all contacts that are male and from Brazil.<br/><br/> The default operator for this is <em>=</em>. <br/> <strong> dbWhere "country", "Brazil" </strong><br/> Translates to:<br/> <strong> WHERE country = 'Brazil' </strong><br/> If you want to change the operator, then call it like:<br/> <strong> dbWhere "age >", "21" </strong><br/> Translates to:<br/> <strong> WHERE age > 21 </strong><br/><br/> You can have as many <em>dbWhere</em> calls as you want. When you finally call a function that touches<br/> the database, it will use all those <em>where clauses</em>.<br/><br/> <em>Remember: after calling a function that touches the database such as dbGet(), all the query parameters are reset</em><br/><br/> <em>Parameters:</em> a column and a value to look for.<br/> <em>Parameters:</em> a column, an operator for the comparison and a value to look for.<br/><br/> As a convention, the standard operator for multiple dbWhere calls is AND<br/> so if you call<br/><br/> <strong> dbWhere "country", "Brazil" </strong><br/> <strong> dbWhere "age >", "21" </strong><br/> <strong> put dbGet("contacts") into tR </strong><br/><br/> Translates to the following SQL:<br/><br/> <strong> SELECT * FROM contacts WHERE country = 'Brazil' AND age > 21 </strong><br/><br/> Now, if you want  to use <strong>OR<strong> instead of </strong>AND</strong>, you just pass an third extra parameter with<br/> the operator you want, like:<br/><br/> <strong> dbWhere "country", "Brazil" </strong><br/> <strong> dbWhere "age >", "21", "OR" </strong><br/> <strong> put dbGet("contacts") into tR </strong><br/><br/> Translates to the following SQL:<br/><br/> <strong> SELECT * FROM contacts WHERE country = 'Brazil' OR age > 21 </strong><br/><br/> If you want to check if a column is null use a command like:<br/><br/>  <strong> dbWhere "country", "NULL" </strong><br/><br/> If you want to check if a column is not null use a command like:<br/><br/> <strong> dbWhere "country", "NOT NULL" </strong><br/><br/></p></div></div><div class="method-detail">        <a name="dbSetSQL" />        <div class="method-heading"><a class="method-signature"> <span class="method-name">dbSetSQL</span> <span class="method-args">Type: Command    Scope: Public Params: pSQL</span></a></div><div class="method-description"><p> This command allows you to specify the SQL statement to use in the next function that touches<br/> the database.<br/> Sometimes you need to write a complex SQL statement that is beyond what we offer with routines<br/> such as <em>dbWhere, dbLike, dbLimit</em>, in this cases you can still use our handy database functions<br/> but specify the SQL statement yourself. <br/><br/> For example:<br/> <strong> dbSetSQL "SELECT * FROM page, tags WHERE tags.page_id = page.id" </strong><br/> <strong> put dbGet() into tPagesAndTagsArray </strong><br/> <br/> Our commands and functions cover most of the common uses for application database usage<br/> but if you need more, you can always write your own SQL. The golden rule is: <em>if you know what a join is, then you can write it better than the library</em>.<br/><br/> <em>Parameters:</em> A SQL Statement.<br/></p></div></div><div class="method-detail">        <a name="dbLike" />        <div class="method-heading"><a class="method-signature"> <span class="method-name">dbLike</span> <span class="method-args">Type: Command    Scope: Public Params: pColumn, pValue, pMatch, pConcatenationOperator</span></a></div><div class="method-description"><p> This command allows you to refine your query. Use it before calling functions such as: <em>dbGet, dbUpdate, dbDelete</em>.<br/><br/> If a code like:<br/> <strong> put dbGet("contacts") into tDataA </strong><br/> returns all the contacts. Then a code like:<br/> <strong> dbLike "email", "runrev.com" </strong><br/> <strong> put dbGet("contacts") into tDataA </strong><br/> Will return all contacts with emails from runrev.com<br/><br/> The default matching routine for this <em>contains</em>.  <br/> <strong> dbLike "email", "runrev.com" </strong><br/> Translates to:<br/> <strong> WHERE email LIKE '%runrev.com%' </strong><br/> If you want to change the matching routines, then call it like:<br/> <strong> dbLike "name", "john", "after" </strong><br/> Translates to:<br/> <strong> WHERE name LIKE 'john%' </strong><br/> This will return all contacts with names starting with John.<br/><br/> You can have as many dbLike calls as you want. When you finally call a function that touches<br/> the database, it will use all those <em>where clauses</em>.<br/><br/> <em>Remember: after calling a function that touches the database such as dbGet(), all the query parameters are reset</em><br/><br/> <em>Parameters:</em> a column and a value to look for.<br/> <em>Parameters:</em> a column, a value to look for and where to put the wildcard.<br/><br/> As a convention, the standard operator for multiple dbWhere calls is AND<br/> so if you call<br/><br/> <strong> dbLike "email", "runrev.com" </strong><br/> <strong> dbLike "first_name", "Kevin" </strong><br/> <strong> put dbGet("contacts") into tR </strong><br/><br/> Translates to the following SQL:<br/><br/> <strong> SELECT * FROM contacts WHERE email LIKE '%runrev.com%' AND first_name LIKE '%Kevin%' </strong><br/><br/> Now, if you want  to use <strong>OR<strong> instead of </strong>AND</strong>, you just pass an fourth extra parameter with<br/> the operator you want, like:<br/><br/> <strong> dbLike "email", "runrev.com" </strong><br/> <strong> dbLike "first_name", "Kevin", "after", "OR" </strong><br/> <strong> put dbGet("contacts") into tR </strong><br/><br/> Translates to the following SQL:<br/><br/> <strong> SELECT * FROM contacts WHERE email LIKE '%runrev.com%' OR first_name LIKE 'Kevin%' </strong><br/><br/></p></div></div><div class="method-detail">        <a name="dbOrderBy" />        <div class="method-heading"><a class="method-signature"> <span class="method-name">dbOrderBy</span> <span class="method-args">Type: Command    Scope: Public Params: pOrderBy</span></a></div><div class="method-description"><p> Sets the ordering for a query.<br/> <br/> <strong> dbOrder 'age' </strong><br/> <strong> put dbGet("contacts") into tDataA </strong><br/><br/> Will return the contacts array ordered by age.<br/> <em>Parameters:</em> A valid column or clause for the ordering.<br/></p></div></div><div class="method-detail">        <a name="dbColumns" />        <div class="method-heading"><a class="method-signature"> <span class="method-name">dbColumns</span> <span class="method-args">Type: Command    Scope: Public Params: pColumns</span></a></div><div class="method-description"><p> This command receives a comma separated list of column names <br/> that you want to be included in your next database call.<br/> By default, database queries include all columns. This behavior can be changed with this command.<br/> *Parameters: a comma separated list of columns<br/></p></div></div><div class="method-detail">        <a name="dbLastRowid" />        <div class="method-heading"><a class="method-signature"> <span class="method-name">dbLastRowid</span> <span class="method-args">Type: Function    Scope: Public Params: pTable</span></a></div><div class="method-description"><p> Returns the id for the last inserted, updated or deleted record on a given table.<br/> This is for SQLite only.<br/><br/> <em>Parameters:</em> A table name.<br/><br/></p></div></div><div class="method-detail">        <a name="dbCardToArray" />        <div class="method-heading"><a class="method-signature"> <span class="method-name">dbCardToArray</span> <span class="method-args">Type: Function    Scope: Public Params: pTable, pDatabaseConnectionID</span></a></div><div class="method-description"><p> This command will look into the current card for fields, buttons and groups<br/> with the same name as the fields on a given database table. If it finds the correct controls<br/> it picks their values and assemble an array to be used by the database touching functions.<br/><br/> If you have a card with a field called "firstName", a field called "lastName" and a menu button <br/> called "country" which are all fields on your <em>contacts</em> table and you use:<br/><br/> <strong> put dbCardToArray("contacts") into tDataA </strong><br/><br/> it is the same as writing:<br/><br/> <strong> put unidecode(the unicodetext of field "firstName", "unicode") into tDataA["firstName"] </strong><br/> <strong> put unidecode(the unicodetext of field "lastName", "unicode") into tDataA["lastName"] </strong><br/> <strong> put the label of button "country" into tDataA["country"] </strong><br/><br/> So it follows these rules:<br/> 1 - it looks for a field, it there is one, then it picks the unicodetext property and unidecodes it into the array.<br/> 2 - it looks for a button and places the label into the array.<br/> 3 - it looks for a group and places the value from the custom property <em>dbvalue</em> into the array.<br/><br/> <strong>REMEMBER:</strong> if you're using groups for your mobile controls, just script a <em>setprop dbvalue</em> and<br/> a <em>getprop dbvalue</em> for the group to be able to exchange data with this command.<br/><br/> <em>Parameters:</em> a table name.<br/> <em>Parameters:</em> a table name and a connection id.<br/> <br/> <em>Returns:</em> an array<br/></p></div></div><div class="method-detail">        <a name="dbRestoreQueryParameters" />        <div class="method-heading"><a class="method-signature"> <span class="method-name">dbRestoreQueryParameters</span> <span class="method-args">Type: Command    Scope: Public Params: pDataA</span></a></div><div class="method-description"><p> This will restore the query parameters replacing the current parameters. You can use <em>dbPreserveQueryParameters</em><br/> to save the query parameters to an array.<br/> <em>Parameters:</em> An array with the query parameters.<br/></p></div></div><div class="method-detail">        <a name="dbPreserveQueryParameters" />        <div class="method-heading"><a class="method-signature"> <span class="method-name">dbPreserveQueryParameters</span> <span class="method-args">Type: Function    Scope: Public Params: </span></a></div><div class="method-description"><p> This will return the current query parameters. You can use <em>dbRestoreQueryParameters</em> to <br/> restore it later. This is useful when you're creating routines and don't want other queries to <br/> pollute your current parameters.<br/> <em>Returns:</em> An array with the current parameters.<br/></p></div></div><div class="method-detail">        <a name="dbSetDefaultConnectionID" />        <div class="method-heading"><a class="method-signature"> <span class="method-name">dbSetDefaultConnectionID</span> <span class="method-args">Type: Command    Scope: Public Params: pID</span></a></div><div class="method-description"><p> Sets the default <em>Database Connection ID</em> for the calls.<br/> <em>Parameter:</em> You pass the connection id number.<br/></p></div></div><div class="method-detail">        <a name="dbResetQuery" />        <div class="method-heading"><a class="method-signature"> <span class="method-name">dbResetQuery</span> <span class="method-args">Type: Command    Scope: Public Params: </span></a></div><div class="method-description"><p> This clears the current query. As you use commands such as <em>dbColumns, dbWhere, dbLimit</em>,<br/> you refine your query parameters before calling it. Sometimes, you want to reset all back to empty.<br/></p></div></div></body></html>